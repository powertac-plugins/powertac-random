/*
 * Copyright 2011 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an
 * "AS IS" BASIS,  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */

package org.powertac.random

import java.security.SecureRandom

/**
 * RandomSeedService provides a thin wrapper around {@link java.security.SecureRandom}
 * With {@code replay} set to {@code false} it generates random numbers on
 * demand and stores them in the database, also persisting the class, id, and purpose
 * of the entity that invoked the service.
 * <p>
 * Any module (perhaps a Customer model) that needs a sequence of random numbers must 
 * request a seed from RandomSeedService, and then use that seed to initialize a 
 * java.util.Random instance, which it henceforth uses to generate its random values. 
 * If we need distributions other than uniform and gaussian, we can add some utility
 * wrappers that produce the needed distributions.</p>
 * <p>
 * The purpose of RandomSeedService is to permit re-play of a random sequence, and 
 * therefore an exact repeat of game conditions in order to compare performance of 
 * different agent configurations. In order for this to work, it's necessary that the 
 * sequence of random numbers generated by a server module be completely independent 
 * of agent behavior. So for example, if we have a customer model that uses random 
 * numbers to produce its consumption and production behaviors, we cannot write code 
 * that uses extra random values in cases where the customer is responding to a 
 * variable-rate tariff. This can create some interesting design challenges; one way 
 * to deal with this might be to use multiple random sequences inside such a model, 
 * one for behaviors that are independent of broker actions, and another for each 
 * individual broker whose actions require the customer to generate additional random 
 * values. This problem can also create interesting testing challenges -- exactly what 
 * they are is left as an exercise for the interested reader.</p>
 * <p>
 * With {@code replay} set to true, the service
 * tries to serve the originally generated random seeds from the
 * database. Only if db lookup fails, a new random number is generated and persisted to the
 * database.</p>
 *
 * @author Carsten Block, John Collins
 */
class RandomSeedService {

  static transactional = true
  static def random = new SecureRandom()
  static boolean replay = false

  long nextSeed (requesterClass, requesterId, purpose)
  {
    assert (requesterClass)
    assert (purpose)

    RandomSeed randomSeed = RandomSeed.withCriteria(uniqueResult: true) {
      eq('requesterClass', requesterClass)
      if (requesterId) {
        eq('requesterId', requesterId)
      } 
      else {
        isNull('requesterId')
      }
      eq('purpose', purpose)
      maxResults(1)
      order('id', 'desc')
    }
    long randomValue = random.nextLong()
    if (replay) {
      if (!randomSeed) {
        log.error("PowerTAC random service in replay mode but no seed found in db for requesterId: '$requesterId', purpose: '$purpose'. Generating new seed...")
        randomSeed = new RandomSeed(requesterClass: requesterClass, requesterId: requesterId, purpose: purpose, value: randomValue.toString())
        assert (randomSeed.validate() && randomSeed.save())
      } 
      else {
        randomValue = randomSeed.value
      }
    } 
    else {
      if (!randomSeed) {
        randomSeed = new RandomSeed(requesterClass: requesterClass, requesterId: requesterId, purpose: purpose, value: randomValue)
        assert (randomSeed.validate() && randomSeed.save())
      } 
      else {
        if (log.isInfoEnabled()) log.info("Overwriting random seed '${randomSeed.value}' for requesterId: '$requesterId', purpose: '$purpose', seedType: '${seedType}' with '${randomValue}'")
        randomSeed.value = randomValue
        assert (randomSeed.validate() && randomSeed.save())
      }
    }
    return randomValue
  }
}
